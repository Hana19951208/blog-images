name: Compress and Preheat
on:
  push:
    paths:
      - '**.jpg'
      - '**.jpeg'
      - '**.png'
      - '**.webp'
  workflow_dispatch:

# 确保并发上传时排队执行，防止 Git 提交冲突
concurrency:
  group: image-hosting
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 1. 筛选本次新增图片
        id: filter
        run: |
          # 获取新增 (A) 和修改 (M) 的图片路径
          IMAGES=$(git diff --name-only --diff-filter=AM HEAD^ HEAD | grep -E "\.(jpg|jpeg|png|webp)$" | xargs echo || true)
          
          if [ -z "$IMAGES" ]; then
            echo "has_images=false" >> $GITHUB_OUTPUT
            echo ">>> [信息] 未发现新增图片。"
          else
            echo "has_images=true" >> $GITHUB_OUTPUT
            echo "IMAGES_LIST=$IMAGES" >> $GITHUB_OUTPUT
            echo ">>> [信息] 待处理图片: $IMAGES"
          fi

      - name: 2. 安装并执行增量压缩
        if: steps.filter.outputs.has_images == 'true'
        run: |
          # 安装轻量级压缩工具
          sudo apt-get update && sudo apt-get install -y jpegoptim optipng webp
          
          # 仅针对筛选出的文件进行循环压缩
          for FILE in ${{ steps.filter.outputs.IMAGES_LIST }}; do
            echo ">>> [处理中] $FILE"
            if [[ $FILE == *.jpg ]] || [[ $FILE == *.jpeg ]]; then
              jpegoptim --size=400k "$FILE" # 限制大小在 400k 以内
            elif [[ $FILE == *.png ]]; then
              optipng -o2 "$FILE"
            elif [[ $FILE == *.webp ]]; then
              echo ">>> [跳过] WebP 文件通常已优化，跳过二次压缩。"
            fi
          done


      - name: 3. 自动提交 (修复匹配报错)
        if: steps.filter.outputs.has_images == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          # 【修复】不指定具体后缀，由插件自动检测变更的文件，避免 pathspec 报错
          commit_message: "chore: 自动化压缩图片 [skip ci]"
          branch: main
          # 去掉 file_pattern，让它自动 add 变动的文件

      - name: 4. 等待同步并预热 CDN
        if: steps.filter.outputs.has_images == 'true'
        env:
          # 提供域名默认值兜底
          CDN_DOMAIN: ${{ secrets.CDN_DOMAIN || 'img.fangenwu.cn' }}
          FILES: ${{ steps.filter.outputs.IMAGES_LIST }}
        run: |
          sleep 10 # 等待 GitHub Raw 更新
          echo ">>> [日志] 开始针对新图片进行预热..."
          for FILE in $FILES; do
            URL="https://$CDN_DOMAIN/$FILE"
            # -L 跟随重定向，-I 获取头信息触发缓存
            STATUS=$(curl -s -L -o /dev/null -I -w "%{http_code}" "$URL")
            echo ">>> [预热结果] $STATUS - $URL"
          done

      - name: 5. 同步至微信公众号 (中转服务器执行)
        if: steps.filter.outputs.has_images == 'true'
        uses: appleboy/ssh-action@v1.0.3
        env:
          WECHAT_APP_ID: ${{ secrets.WECHAT_APP_ID }}
          WECHAT_APP_SECRET: ${{ secrets.WECHAT_APP_SECRET }}
          IMAGES_LIST: ${{ steps.filter.outputs.IMAGES_LIST }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_KEY }}
          envs: WECHAT_APP_ID,WECHAT_APP_SECRET,IMAGES_LIST
          script: |
            # 1. 创建临时目录
            WORK_DIR="/tmp/blog-images-sync-${{ github.run_id }}"
            mkdir -p $WORK_DIR
            
            # 2. 准备脚本 (直接写入内容，避免 SCP 复杂性)
            cat > $WORK_DIR/sync_to_wechat.py << 'EOF'
            import os, requests, sys, time

            # 从环境变量获取配置
            APP_ID = os.environ.get('WECHAT_APP_ID')
            APP_SECRET = os.environ.get('WECHAT_APP_SECRET')
            
            # 文件列表
            if len(sys.argv) > 1:
                IMAGES_LIST = sys.argv[1].split()
            else:
                IMAGES_LIST = []

            def get_access_token():
                if not APP_ID or not APP_SECRET:
                    print("❌ 错误：未配置 WECHAT_APP_ID 或 WECHAT_APP_SECRET")
                    return None
                url = f"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={APP_ID}&secret={APP_SECRET}"
                try:
                    res = requests.get(url, timeout=10)
                    data = res.json()
                    return data.get('access_token')
                except Exception as e:
                    print(f"❌ Token 获取异常: {e}")
                    return None

            def upload_image(token, file_path):
                url = f"https://api.weixin.qq.com/cgi-bin/material/add_material?access_token={token}&type=image"
                file_name = os.path.basename(file_path)
                # 使用完整路径作为 Title，方便后续搜索识别 (微信可能不支持斜杠，替换为下划线)
                # 微信素材库是扁平的，这里用文件名作为标题标识
                title = file_path.replace("/", "_")
                
                try:
                    with open(file_path, 'rb') as f:
                        files = {'media': (file_name, f)}
                        # 永久素材上传
                        res = requests.post(url, files=files, timeout=30)
                        return res.json()
                except Exception as e:
                    return {"errcode": -1, "errmsg": str(e)}

            def main():
                print(">>> [WeChat Sync] Start...")
                if not IMAGES_LIST:
                    print(">>> No images to sync.")
                    return

                token = get_access_token()
                if not token:
                    print(">>> Failed to get access token.")
                    sys.exit(1)

                cwd = os.getcwd() # 当前是在 WORK_DIR
                
                for img_path in IMAGES_LIST:
                    # 图片是通过 wget 下载到当前目录的，保留了目录结构吗？
                    # 这里的逻辑通过 wget 下载图片
                    # GitHub Raw URL: https://raw.githubusercontent.com/<user>/<repo>/main/<path>
                    # 需要拼接完整的 Raw URL
                    
                    # 修正：直接下载到临时文件，名字保持结构以便识别
                    
                    raw_url = f"https://raw.githubusercontent.com/${{ github.repository }}/main/{img_path}"
                    local_filename = img_path.replace("/", "_") # 扁平化文件名
                    
                    print(f">>> Downloading: {raw_url}")
                    try:
                        # 使用 curl 下载
                        os.system(f"curl -s -L -o '{local_filename}' '{raw_url}'")
                    except Exception as e:
                        print(f"❌ Download failed: {e}")
                        continue
                        
                    if not os.path.exists(local_filename):
                        print("❌ File verify failed.")
                        continue

                    print(f">>> Syncing to WeChat: {img_path}")
                    result = upload_image(token, local_filename)
                    
                    if 'media_id' in result:
                        print(f"✅ Synced! MediaID: {result['media_id']}")
                    else:
                        print(f"❌ Failed: {result}")
                    
                    time.sleep(1)

            if __name__ == "__main__":
                main()
            EOF
            
            # 3. 安装依赖 (如果服务器 python 环境没有 requests)
            # 简单检查，如果没有 pip 可能报错，或者用 python3 -m pip
            # 假设服务器有基础 python3 环境。如果担心环境污染，可以创建 venv，但这里追求轻量。
            # 直接尝试运行，如果缺 requests 库则临时安装 (需要 root 权限可能不行，用 --user)
            # 或者仅使用 urllib 标准库重写脚本以零依赖（更稳健）。
            # 鉴于用户是腾讯云，网络环境应该不错，尝试 install requests
            python3 -m pip install requests --user || true
            
            # 4. 执行同步
            # 注意：传入 IMAGES_LIST
            cd $WORK_DIR
            python3 sync_to_wechat.py "$IMAGES_LIST"
            
            # 5. 清理
            cd ..
            rm -rf $WORK_DIR