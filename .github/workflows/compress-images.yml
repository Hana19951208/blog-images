name: Compress and Preheat
on:
  push:
    paths:
      - '**.jpg'
      - '**.jpeg'
      - '**.png'
      - '**.webp'
  workflow_dispatch:

# 确保并发上传时排队执行，防止 Git 提交冲突
concurrency:
  group: image-hosting
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: 1. 筛选本次新增图片
        id: filter
        run: |
          # 获取新增 (A) 和修改 (M) 的图片路径
          IMAGES=$(git diff --name-only --diff-filter=AM HEAD^ HEAD | grep -E "\.(jpg|jpeg|png|webp)$" | xargs echo || true)
          
          if [ -z "$IMAGES" ]; then
            echo "has_images=false" >> $GITHUB_OUTPUT
            echo ">>> [信息] 未发现新增图片。"
          else
            echo "has_images=true" >> $GITHUB_OUTPUT
            echo "IMAGES_LIST=$IMAGES" >> $GITHUB_OUTPUT
            echo ">>> [信息] 待处理图片: $IMAGES"
          fi

      - name: 2. 安装并执行增量压缩
        if: steps.filter.outputs.has_images == 'true'
        run: |
          # 安装轻量级压缩工具
          sudo apt-get update && sudo apt-get install -y jpegoptim optipng webp
          
          # 仅针对筛选出的文件进行循环压缩
          for FILE in ${{ steps.filter.outputs.IMAGES_LIST }}; do
            echo ">>> [处理中] $FILE"
            if [[ $FILE == *.jpg ]] || [[ $FILE == *.jpeg ]]; then
              jpegoptim --size=400k "$FILE" # 限制大小在 400k 以内
            elif [[ $FILE == *.png ]]; then
              optipng -o2 "$FILE"
            elif [[ $FILE == *.webp ]]; then
              echo ">>> [跳过] WebP 文件通常已优化，跳过二次压缩。"
            fi
          done


      - name: 3. 自动提交 (修复匹配报错)
        if: steps.filter.outputs.has_images == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          # 【修复】不指定具体后缀，由插件自动检测变更的文件，避免 pathspec 报错
          commit_message: "chore: 自动化压缩图片 [skip ci]"
          branch: main
          # 去掉 file_pattern，让它自动 add 变动的文件

      - name: 4. 等待同步并预热 CDN
        if: steps.filter.outputs.has_images == 'true'
        env:
          # 提供域名默认值兜底
          CDN_DOMAIN: ${{ secrets.CDN_DOMAIN || 'img.fangenwu.cn' }}
          FILES: ${{ steps.filter.outputs.IMAGES_LIST }}
        run: |
          sleep 10 # 等待 GitHub Raw 更新
          echo ">>> [日志] 开始针对新图片进行预热..."
          for FILE in $FILES; do
            URL="https://$CDN_DOMAIN/$FILE"
            # -L 跟随重定向，-I 获取头信息触发缓存
            STATUS=$(curl -s -L -o /dev/null -I -w "%{http_code}" "$URL")
            echo ">>> [预热结果] $STATUS - $URL"
          done

      - name: 5. 同步至微信公众号 (中转服务器执行)
        if: steps.filter.outputs.has_images == 'true'
        # 【升级】使用更稳定的 v1.2.0 版本，解决现代服务器 SSH 握手失败问题
        uses: appleboy/ssh-action@v1.2.0 
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_KEY }}
          # 【新增】envs 会自动将下方的 env 变量通过 SSH 注入到远程环境
          envs: WECHAT_APP_ID,WECHAT_APP_SECRET,IMAGES_LIST,GITHUB_REPOSITORY
          script: |
            WORK_DIR=~/blog-sync
            mkdir -p $WORK_DIR
            cd $WORK_DIR
            
            # 1. 抓取最新脚本
            echo ">>> [Deploy] 正在更新同步脚本..."
            curl -s -L -o sync_to_wechat.py "https://raw.githubusercontent.com/$GITHUB_REPOSITORY/main/scripts/sync_to_wechat.py"
            
            # 2. 准备环境
            python3 -m pip install requests --user -q
            
            # 3. 执行同步 (下载和重试逻辑已集成在 Python 中)
            echo ">>> [Exec] 启动同步任务..."
            python3 sync_to_wechat.py "$IMAGES_LIST"

        env:
          WECHAT_APP_ID: ${{ secrets.WECHAT_APP_ID }}
          WECHAT_APP_SECRET: ${{ secrets.WECHAT_APP_SECRET }}
          IMAGES_LIST: ${{ steps.filter.outputs.IMAGES_LIST }}
          GITHUB_REPOSITORY: ${{ github.repository }}